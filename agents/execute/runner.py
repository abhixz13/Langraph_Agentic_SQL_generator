"""
SQL Execution Runner

This module handles the execution of SQL queries generated by the SQL generation agent.
It provides safe query execution with result formatting suitable for UI display.
"""

import logging
import sqlite3
import pandas as pd
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import json
from contextlib import contextmanager

from core.state import AppState, create_error_response, create_success_response

logger = logging.getLogger(__name__)

# Configuration
MAX_RESULT_ROWS = 1000  # Maximum rows to return to prevent memory issues
MAX_EXECUTION_TIME = 30  # Maximum execution time in seconds
DEFAULT_DB_PATH = "data/raw_data.db"  # Default database path

# Safety configuration
BLOCKED_KEYWORDS = [
    "DROP", "DELETE", "TRUNCATE", "ALTER", "GRANT", "REVOKE", 
    "CREATE", "INSERT", "UPDATE", "EXEC", "EXECUTE", "CALL"
]


class SQLExecutor:
    """Handles SQL query execution with safety checks and result formatting"""
    
    def __init__(self, db_path: str = DEFAULT_DB_PATH):
        """
        Initialize SQL executor
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = db_path
        self.connection = None
        
    def __enter__(self):
        """Context manager entry"""
        self.connect()
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.disconnect()
        
    def connect(self):
        """Establish database connection"""
        try:
            self.connection = sqlite3.connect(self.db_path)
            # Enable foreign keys and set timeout
            self.connection.execute("PRAGMA foreign_keys = ON")
            self.connection.execute(f"PRAGMA busy_timeout = {MAX_EXECUTION_TIME * 1000}")
            logger.info(f"Connected to database: {self.db_path}")
        except Exception as e:
            logger.error(f"Failed to connect to database: {str(e)}")
            raise
            
    def disconnect(self):
        """Close database connection"""
        if self.connection:
            self.connection.close()
            self.connection = None
            logger.debug("Database connection closed")
            
    def execute_query(self, sql: str) -> Dict[str, Any]:
        """
        Execute SQL query and return formatted results
        
        Args:
            sql: SQL query to execute
            
        Returns:
            Dictionary containing execution results and metadata
        """
        if not self.connection:
            raise RuntimeError("Database not connected")
            
        start_time = datetime.now()
        
        try:
            # Safety check
            if not _is_safe_query(sql):
                return {
                    "success": False,
                    "error": "Query contains unsafe operations",
                    "sql": sql,
                    "execution_time": 0,
                    "rows_returned": 0
                }
            
            # Execute query
            logger.info(f"Executing SQL: {sql[:100]}...")
            
            # Use pandas for better result handling
            df = pd.read_sql_query(sql, self.connection)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            # Limit results if too many rows
            total_rows = len(df)
            if total_rows > MAX_RESULT_ROWS:
                df = df.head(MAX_RESULT_ROWS)
                logger.warning(f"Limited results to {MAX_RESULT_ROWS} rows (total: {total_rows})")
            
            # Convert to records for JSON serialization
            records = df.to_dict('records')
            
            # Get column information
            columns = [
                {
                    "name": col,
                    "type": str(df[col].dtype),
                    "sample_values": df[col].dropna().head(3).tolist()
                }
                for col in df.columns
            ]
            
            result = {
                "success": True,
                "sql": sql,
                "execution_time": execution_time,
                "rows_returned": len(records),
                "total_rows": total_rows,
                "columns": columns,
                "data": records,
                "dataframe": df,  # Keep pandas DataFrame for internal use
                "executed_at": datetime.now().isoformat()
            }
            
            logger.info(f"Query executed successfully: {len(records)} rows in {execution_time:.2f}s")
            return result
            
        except sqlite3.Error as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            logger.error(f"SQL execution error: {str(e)}")
            return {
                "success": False,
                "error": f"SQL execution error: {str(e)}",
                "sql": sql,
                "execution_time": execution_time,
                "rows_returned": 0
            }
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            logger.error(f"Unexpected error during query execution: {str(e)}")
            return {
                "success": False,
                "error": f"Unexpected error: {str(e)}",
                "sql": sql,
                "execution_time": execution_time,
                "rows_returned": 0
            }
    
    def get_table_info(self) -> Dict[str, Any]:
        """
        Get information about all tables in the database
        
        Returns:
            Dictionary containing table information
        """
        if not self.connection:
            raise RuntimeError("Database not connected")
            
        try:
            # Get list of tables
            tables_query = """
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            """
            tables_df = pd.read_sql_query(tables_query, self.connection)
            
            table_info = {}
            for table_name in tables_df['name']:
                # Get table schema
                schema_query = f"PRAGMA table_info({table_name})"
                schema_df = pd.read_sql_query(schema_query, self.connection)
                
                # Get row count
                count_query = f"SELECT COUNT(*) as count FROM {table_name}"
                count_df = pd.read_sql_query(count_query, self.connection)
                row_count = count_df['count'].iloc[0]
                
                table_info[table_name] = {
                    "columns": schema_df.to_dict('records'),
                    "row_count": row_count,
                    "sample_data": pd.read_sql_query(f"SELECT * FROM {table_name} LIMIT 5", self.connection).to_dict('records')
                }
            
            return table_info
            
        except Exception as e:
            logger.error(f"Error getting table info: {str(e)}")
            return {}


def _is_safe_query(sql: str) -> bool:
    """
    Check if SQL query is safe to execute
    
    Args:
        sql: SQL query string
        
    Returns:
        True if query is safe, False otherwise
    """
    if not sql:
        return False
    
    sql_upper = sql.upper()
    
    # Check for blocked keywords
    for keyword in BLOCKED_KEYWORDS:
        if keyword in sql_upper:
            return False
    
    # Basic validation - must start with SELECT
    if not sql_upper.strip().startswith("SELECT"):
        return False
    
    return True


def execute_node(state: AppState) -> Dict[str, Any]:
    """
    Execute SQL query from state and return results
    
    This node takes the SQL query from the state, executes it safely,
    and returns formatted results suitable for UI display.
    
    Runtime Contract:
    Inputs: sql, dialect
    Outputs: execution_result, execution_time, rows_returned, status
    """
    try:
        logger.info("Starting SQL execution")
        
        # Get SQL query from state
        sql = getattr(state, "sql", None)
        if not sql:
            return create_error_response(
                error_message="Cannot execute SQL: missing sql query",
                execution_result=None,
                execution_time=0,
                rows_returned=0,
                status="ERROR"
            )
        
        # Get database path from state or use default
        db_path = getattr(state, "db_path", DEFAULT_DB_PATH)
        
        # Execute query
        with SQLExecutor(db_path) as executor:
            result = executor.execute_query(sql)
        
        if result["success"]:
            # Success case
            patch = create_success_response(
                execution_result=result,
                execution_time=result["execution_time"],
                rows_returned=result["rows_returned"],
                total_rows=result.get("total_rows", result["rows_returned"]),
                columns=result.get("columns", []),
                data=result.get("data", []),
                status="EXECUTED"
            )
            
            logger.info(f"SQL execution completed: {result['rows_returned']} rows in {result['execution_time']:.2f}s")
            return patch
        else:
            # Error case
            return create_error_response(
                error_message=result["error"],
                execution_result=result,
                execution_time=result["execution_time"],
                rows_returned=0,
                status="ERROR"
            )
            
    except Exception as e:
        logger.error(f"SQL execution failed: {str(e)}")
        return create_error_response(
            error_message=f"SQL execution error: {str(e)}",
            execution_result=None,
            execution_time=0,
            rows_returned=0,
            status="ERROR"
        )


def execute_router(state: AppState) -> str:
    """
    Route based on SQL execution results
    
    Routes to:
    - 'present': If SQL was executed successfully
    - 'error': If execution failed
    """
    # Check for errors first
    status = getattr(state, "status", None)
    if status == "ERROR" or getattr(state, "error_message", None):
        logger.warning(f"SQL execution failed, routing to error: {getattr(state, 'error_message', None)}")
        return "error"
    
    # Check for successful execution
    execution_result = getattr(state, "execution_result", None)
    if execution_result and execution_result.get("success", False):
        logger.info("SQL execution successful, routing to present")
        return "present"
    
    logger.warning("SQL execution failed, routing to error")
    return "error"


# UI Integration Functions
def format_results_for_ui(execution_result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Format execution results for UI display
    
    Args:
        execution_result: Raw execution result from SQLExecutor
        
    Returns:
        Formatted result suitable for UI display
    """
    if not execution_result or not execution_result.get("success", False):
        return {
            "success": False,
            "error": execution_result.get("error", "Unknown error") if execution_result else "No result",
            "display_data": None,
            "summary": "Query execution failed"
        }
    
    # Extract data
    data = execution_result.get("data", [])
    columns = execution_result.get("columns", [])
    execution_time = execution_result.get("execution_time", 0)
    rows_returned = execution_result.get("rows_returned", 0)
    total_rows = execution_result.get("total_rows", rows_returned)
    
    # Format for UI display
    display_data = {
        "headers": [col["name"] for col in columns],
        "rows": data,
        "column_info": columns
    }
    
    # Create summary
    summary = f"Query executed successfully in {execution_time:.2f} seconds"
    if rows_returned < total_rows:
        summary += f" (showing {rows_returned} of {total_rows} rows)"
    else:
        summary += f" ({rows_returned} rows returned)"
    
    return {
        "success": True,
        "display_data": display_data,
        "summary": summary,
        "execution_time": execution_time,
        "rows_returned": rows_returned,
        "total_rows": total_rows,
        "sql": execution_result.get("sql", "")
    }


def get_table_schema_for_ui(db_path: str = DEFAULT_DB_PATH) -> Dict[str, Any]:
    """
    Get database schema information formatted for UI display
    
    Args:
        db_path: Path to database file
        
    Returns:
        Schema information formatted for UI
    """
    try:
        with SQLExecutor(db_path) as executor:
            table_info = executor.get_table_info()
        
        # Format for UI
        schema_data = []
        for table_name, info in table_info.items():
            columns = [
                {
                    "name": col["name"],
                    "type": col["type"],
                    "not_null": bool(col["notnull"]),
                    "primary_key": bool(col["pk"])
                }
                for col in info["columns"]
            ]
            
            schema_data.append({
                "table_name": table_name,
                "columns": columns,
                "row_count": info["row_count"],
                "sample_data": info["sample_data"]
            })
        
        return {
            "success": True,
            "tables": schema_data,
            "total_tables": len(schema_data)
        }
        
    except Exception as e:
        logger.error(f"Error getting schema for UI: {str(e)}")
        return {
            "success": False,
            "error": str(e),
            "tables": [],
            "total_tables": 0
        }


# Gradio Integration Functions
def create_gradio_interface():
    """
    Create Gradio interface components for SQL execution
    
    Returns:
        Dictionary containing Gradio components and functions
    """
    import gradio as gr
    
    def execute_sql_for_gradio(sql_query: str, db_path: str = DEFAULT_DB_PATH) -> Tuple[str, str, Any]:
        """
        Execute SQL query for Gradio interface
        
        Args:
            sql_query: SQL query to execute
            db_path: Database path
            
        Returns:
            Tuple of (formatted_result, summary, data_for_display)
        """
        try:
            with SQLExecutor(db_path) as executor:
                result = executor.execute_query(sql_query)
            
            formatted_result = format_results_for_ui(result)
            
            if formatted_result["success"]:
                # Create DataFrame for Gradio display
                import pandas as pd
                df = pd.DataFrame(formatted_result["display_data"]["rows"])
                
                return (
                    formatted_result["summary"],
                    formatted_result["sql"],
                    df
                )
            else:
                return (
                    f"Error: {formatted_result['error']}",
                    sql_query,
                    None
                )
                
        except Exception as e:
            return (
                f"Error: {str(e)}",
                sql_query,
                None
            )
    
    def get_schema_for_gradio(db_path: str = DEFAULT_DB_PATH) -> str:
        """
        Get database schema for Gradio display
        
        Args:
            db_path: Database path
            
        Returns:
            Formatted schema string
        """
        schema_info = get_table_schema_for_ui(db_path)
        
        if not schema_info["success"]:
            return f"Error loading schema: {schema_info['error']}"
        
        schema_text = "Database Schema:\n\n"
        for table in schema_info["tables"]:
            schema_text += f"Table: {table['table_name']} ({table['row_count']} rows)\n"
            schema_text += "Columns:\n"
            for col in table["columns"]:
                pk_flag = " (PK)" if col["primary_key"] else ""
                null_flag = " NOT NULL" if col["not_null"] else ""
                schema_text += f"  - {col['name']}: {col['type']}{pk_flag}{null_flag}\n"
            schema_text += "\n"
        
        return schema_text
    
    return {
        "execute_function": execute_sql_for_gradio,
        "schema_function": get_schema_for_gradio,
        "components": {
            "sql_input": gr.Textbox(label="SQL Query", lines=5, placeholder="Enter your SQL query here..."),
            "db_path_input": gr.Textbox(label="Database Path", value=DEFAULT_DB_PATH),
            "execute_button": gr.Button("Execute Query", variant="primary"),
            "result_summary": gr.Textbox(label="Execution Summary", interactive=False),
            "result_sql": gr.Textbox(label="Executed SQL", interactive=False),
            "result_table": gr.Dataframe(label="Query Results"),
            "schema_button": gr.Button("Show Database Schema"),
            "schema_output": gr.Textbox(label="Database Schema", lines=10, interactive=False)
        }
    }


# Export main functions
__all__ = [
    "execute_node",
    "execute_router", 
    "SQLExecutor",
    "format_results_for_ui",
    "get_table_schema_for_ui",
    "create_gradio_interface"
]
